package tal

import (
	"bytes"
	"encoding/gob"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/google/uuid"
	"golang.org/x/exp/slices"
	. "nyiyui.ca/hato/sakayukari"
	"nyiyui.ca/hato/sakayukari/conn"
	"nyiyui.ca/hato/sakayukari/tal/cars"
	"nyiyui.ca/hato/sakayukari/tal/layout"
)

type LineID = layout.LineID
type LinePort = layout.LinePort

const idlePower = 20

type GuideConf struct {
	Layout        *layout.Layout
	Actors        map[LineID]ActorRef
	actorsReverse map[ActorRef]conn.Id
	Cars          cars.Data
}

type TrainState int

const (
	// TrainStateNextAvail means the next line is available. The train should move to the next line.
	TrainStateNextAvail TrainState = 1
	// TrainStateNextLocked means the next line is locked by another train. The train should stop and wait at its current position, unless a precise attitude is available. If a precise attitude is available, it should stop without entering the next line.
	TrainStateNextLocked TrainState = 2
)

type FormOrient int

const (
	FormOrientA FormOrient = iota + 1
	FormOrientB
)

// Flip returns the opposite orientation (A → B, B → A).
// If f is not A or B, this function panics.
func (f FormOrient) Flip() FormOrient {
	switch f {
	case FormOrientA:
		return FormOrientB
	case FormOrientB:
		return FormOrientA
	default:
		panic(fmt.Sprintf("invalid FormOrient %d", f))
	}
}

func (f FormOrient) String() string {
	switch f {
	case FormOrientA:
		return "fA"
	case FormOrientB:
		return "fB"
	default:
		return fmt.Sprintf("FormOrient_invalid_%d", f)
	}
}

type Train struct {
	// Generation is incremented when Path, StateFormI, or Orient changes.
	Generation int
	// TODO: GenerationChanges (e.g. did power, orient change?)

	// Power supplied directly to soyuu-line (when moving)
	Power           int
	noPowerSupplied bool

	// dynamic fields

	// CurrentBack is the path index of the last car's occupying line (includes trailers).
	// Must always be larger than 0.
	CurrentBack int
	// CurrentFront is the path index of the first car's occupying line (includes trailers).
	// Must always be larger than 0.
	CurrentFront int
	// MotorBack is the path index of the last motor car's occupying line.
	// Must always be larger than 0.
	MotorBack int
	// MotorFront is the path index of the first motor car's occupying line.
	// Must always be larger than 0.
	MotorFront int
	// Path is the Path of outgoing LinePorts until the goal.
	// This should be generated by FullPathTo, and must contain on index 0 a LinePort with the same line as index 1 and a opposite port to index 1's LinePort.
	Path  *layout.FullPath
	State TrainState

	FormI uuid.UUID
	// Orient shows which side (side A or B) the front of the train (c.f. CurrentFront etc).
	Orient FormOrient
}

// nextUnsafe returns the path index of the next LinePort.
// Note: this does check if this train has a next available, and panics if next is not available.
func (t *Train) next() int {
	if t.State != TrainStateNextAvail {
		panic("next() called when not trainStateNextAvail")
	}
	return t.nextUnsafe()
}

// nextUnsafe returns the path index of the next LinePort.
// Note: this does not check if this train has a next available.
func (t *Train) nextUnsafe() int {
	return t.CurrentFront + 1
}

func (t *Train) String() string {
	b := new(strings.Builder)
	fmt.Fprintf(b, "power%d %d-%d", t.Power, t.CurrentBack, t.CurrentFront)
	switch t.State {
	case TrainStateNextAvail:
		fmt.Fprintf(b, "→%d", t.next())
	case TrainStateNextLocked:
		fmt.Fprintf(b, "L")
	}
	fmt.Fprintf(b, " S%sF", t.Path.Start)
	for _, lp := range t.Path.Follows {
		fmt.Fprintf(b, " %s", lp)
	}
	return b.String()
}

type guide struct {
	actor      Actor
	conf       GuideConf
	trains     []Train
	lineStates []LineStates
	y          *layout.Layout
}

type LineStates struct {
	Taken           bool
	TakenBy         int
	PowerActor      ActorRef
	Power           uint8
	SwitchActor     ActorRef
	SwitchState     SwitchState
	nextSwitchState SwitchState
}

func Guide(conf GuideConf) Actor {
	a := Actor{
		Comment:  "tal-guide",
		InputCh:  make(chan Diffuse1),
		OutputCh: make(chan Diffuse1),
		Inputs:   make([]ActorRef, 0),
		Type: ActorType{
			Input:       true,
			LinearInput: true,
			Output:      true,
		},
	}
	for _, l := range conf.Layout.Lines {
		a.Inputs = append(a.Inputs, conf.Actors[l.PowerConn])
		if l.IsSwitch() {
			a.Inputs = append(a.Inputs, conf.Actors[l.SwitchConn])
		}
	}
	conf.actorsReverse = map[ActorRef]conn.Id{}
	for li, ar := range conf.Actors {
		conf.actorsReverse[ar] = li.Conn
	}
	g := guide{
		conf:       conf,
		actor:      a,
		trains:     make([]Train, 0),
		lineStates: make([]LineStates, len(conf.Layout.Lines)),
		y:          conf.Layout,
	}
	t1 := Train{
		Power:        60,
		CurrentBack:  0,
		CurrentFront: 0,
		State:        TrainStateNextAvail,
		//FormI:        uuid.MustParse("e5f6bb45-0abe-408c-b8e0-e2772f3bbdb0"),
		FormI: uuid.MustParse("2fe1cbb0-b584-45f5-96ec-a9bfd55b1e91"),
		//FormI:  uuid.MustParse("7b920d78-0c1b-49ef-ab2e-c1209f49bbc6"),
		Orient: FormOrientA,
	}
	path := g.y.MustFullPathTo(LinePort{g.y.MustLookupIndex("W"), layout.PortB}, LinePort{g.y.MustLookupIndex("Z"), layout.PortA})
	t1.Path = &path
	g.trains = append(g.trains, t1)

	go g.loop()
	return a
}

func (g *guide) updateCurrent() {
	for ti, t := range g.trains {
		t.CurrentBack = t.MotorBack - 1
		if t.CurrentBack < 0 {
			t.CurrentBack = 0
		}
		t.CurrentFront = t.MotorFront + 1
		if t.MotorFront >= len(t.Path.Follows) {
			t.MotorFront = len(t.Path.Follows) - 1
		}
		continue
		// TODO: fix
		// back is the length from port A of MotorBack to the backside of the trailers.
		var back int64
		// front is the length from port A of MotorFront to the frontside of the trailers.
		var front int64
		{
			sideA, sideB := g.conf.Cars.Forms[t.FormI].TrailerLength()
			switch t.Orient {
			case FormOrientA:
				front, back = sideA, sideB
			case FormOrientB:
				front, back = sideB, sideA
			}
			var behindBack LinePort
			if t.MotorBack == 0 {
				behindBack = t.Path.Start
			} else {
				behindBack = t.Path.Follows[t.MotorBack-1]
			}
			// backside is the backmost port of MotorBack.
			backside := g.y.GetPort(behindBack).Conn()
			if backside.PortI != layout.PortA {
				back += int64(g.y.GetPort(backside).Length)
			}
			if lp := t.Path.Follows[t.MotorFront]; lp.PortI != layout.PortA {
				_, p := g.y.GetLinePort(lp)
				front += int64(p.Length)
			}
		}
		{
			r := g.y.ReverseFullPath(*t.Path)
			path := r.Follows
			path = path[slices.IndexFunc(path, func(lp LinePort) bool { return lp.LineI == t.Path.Follows[t.MotorBack].LineI }):]
			trailer, ok := g.y.Traverse(path, back)
			if !ok {
				// It seems that the trailers overran...but we don't care! :D
				log.Printf("train %d overrun (back)", ti)
				t.CurrentBack = 0
			} else {
				t.CurrentBack = slices.IndexFunc(t.Path.Follows, func(lp LinePort) bool { return lp.LineI == trailer.LineI })
				if t.CurrentBack == -1 {
					panic("unreacheable")
				}
			}
		}
		{
			path := t.Path.Follows
			path = path[t.MotorFront:]
			trailer, ok := g.y.Traverse(path, front)
			if !ok {
				// It seems that the trailers overran...but we don't care! :D
				log.Printf("train %d overrun (front)", ti)
				t.CurrentFront = len(t.Path.Follows) - 1
			} else {
				t.CurrentFront = slices.IndexFunc(t.Path.Follows, func(lp LinePort) bool { return lp.LineI == trailer.LineI })
				if t.CurrentFront == -1 {
					panic("unreacheable")
				}
			}
		}
		/*
			{
				var lp LinePort
				if t.MotorBack > 0 {
					lp = t.Path.Follows[t.MotorBack]
				} else {
					lp = t.Path.Start
				}
				if lp.PortI != layout.PortA {
					// While back currently contains the length of trailers from the backside,
					// it has to contain the length from port A of CurrentBack.
					_, p := g.y.GetLinePort(lp)
					back += int64(p.Length)
				}
				reversed := g.y.ReverseFullPath(*t.Path).Follows
				var path []LinePort
				if t.MotorBack > 0 {
					path = reversed[:slices.IndexFunc(reversed, func(lp LinePort) bool { return lp.LineI == t.Path.Follows[t.MotorBack-1].LineI })]
					// handle when t.MotorBack points to the last LinePort in t.Path, and therefore is reversed.Start
				} else {
					path = reversed[:slices.Index(reversed, t.Path.Start)]
				}
				backPos, ok := g.y.Traverse(path, back)
				if !ok {
					// It seems that the trailers overran...but we don't care! :D
					log.Printf("train %d overrun (back)", ti)
					t.CurrentBack = len(t.Path.Follows) - 1
				} else {
					t.CurrentBack = slices.IndexFunc(t.Path.Follows, func(lp LinePort) bool { return lp.LineI == backPos.LineI })
					if t.CurrentBack == -1 {
						panic("unreacheable")
					}
				}
			}
			// TODO: MotorFront
		*/
	}
}

func (g *guide) handleValCurrent(diffuse Diffuse1, cur conn.ValCurrent) {
	ci, ok := g.conf.actorsReverse[diffuse.Origin]
	if !ok {
		log.Printf("unknown conn for actor %s", diffuse.Origin)
		return
	}
	//log.Printf("=== diffuse from %s: %s", ci, cur)
	for ti := range g.trains {
		for _, inner := range cur.Values {
			t := g.trains[ti]
			if t.noPowerSupplied {
				continue
			}
			// sync t.state etc
			g.syncLocks(ti)
			t = g.trains[ti]

			cb := g.y.Lines[t.Path.Follows[t.MotorBack].LineI]
			if ci == cb.PowerConn.Conn && inner.Line == cb.PowerConn.Line && !inner.Flow {
				if t.MotorBack >= t.MotorFront {
					// this can happen e.g. when the train is at 0-0→1 and then the 0th line becomes 0 (e.g. A0, B0)
					goto NoMotorBack
				}
				nextI := t.Path.Follows[t.MotorBack].LineI
				g.unlock(nextI)
				g.apply(&t, t.MotorBack, 0)
				t.MotorBack++
				//log.Printf("=== currentBack succession: %d", t.MotorBack)
				g.publishChange(ti, ChangeTypeCurrentBack)
			}
		NoMotorBack:
			cf := g.y.Lines[t.Path.Follows[t.MotorFront].LineI]
			if ci == cf.PowerConn.Conn && inner.Line == cf.PowerConn.Line && !inner.Flow {
				if t.MotorFront == 0 {
					//log.Printf("=== currentFront regression (ignore): %d", t.MotorFront)
					goto NoMotorFront
				}
				if t.MotorFront <= t.MotorBack {
					// this can happen e.g. when the train is at 1-1→2 and then the 1st line becomes 0 (e.g. A0, B0) (currentBack moving to 0 is prevented by an if for currentBack)
					//log.Printf("=== currentFront regression (ignore as currentFront <= currentBack): %d", t.MotorFront)
					goto NoMotorFront
				}
				nextI := t.Path.Follows[t.MotorFront].LineI
				g.unlock(nextI)
				g.apply(&t, t.MotorFront, 0)
				t.MotorFront--
				g.publishChange(ti, ChangeTypeCurrentFront)
				//log.Printf("=== currentFront regression: %d", t.MotorFront)
			}
		NoMotorFront:
			if t.State == TrainStateNextAvail {
				// if t.state ≠ trainStateNextAvail, t.next could be out of range
				cf := g.y.Lines[t.Path.Follows[t.next()].LineI]
				if ci == cf.PowerConn.Conn && inner.Line == cf.PowerConn.Line && inner.Flow {
					t.MotorFront++
					g.publishChange(ti, ChangeTypeCurrentFront)
					//log.Printf("=== next succession: %d", t.MotorFront)
				}
			}
			g.trains[ti] = t
		}
		// TODO: check if the train derailed, was removed, etc (come up with a heuristic)
		// TODO: check for regressions
		// TODO: check for overruns (is this possible?)
		//log.Printf("postshow: %s", &g.trains[ti])
	}
	g.updateCurrent()
	g.publishSnapshot()
	for ti := range g.trains {
		g.wakeup(ti)
		//log.Printf("postwakeup: %s", &g.trains[ti])
	}
	g.publishSnapshot()
}

func (g *guide) wakeup(ti int) {
	log.Printf("wakeup %d", ti)
	log.Printf("wakeup %#v", g.trains[ti])
	log.Printf("wakeup %#v", g.trains[ti].Path)
	g.check(ti)
	g.syncLocks(ti)
	t := g.trains[ti]
	g.reify(ti, &t)
	g.trains[ti] = t
}

func (g *guide) check(ti int) {
	t := g.trains[ti]
	if t.Power < 0 {
		panic(fmt.Sprintf("TrainI %d: negative power: %#v", ti, t))
	}
}

func (g *guide) loop() {
	time.Sleep(1 * time.Second)
	for ti := range g.trains {
		g.wakeup(ti)
	}
	g.publishSnapshot()
	for diffuse := range g.actor.InputCh {
		switch val := diffuse.Value.(type) {
		case GuideTrainUpdate:
			log.Printf("diffuse GuideTrainUpdate %d %#v", val.TrainI, val.Train)
			orig := g.trains[val.TrainI]
			if val.Train.Power == -1 {
				val.Train.Power = orig.Power
			}
			// TODO: disallow manually setting CurrentBack/Front (and base changing MotorBack/Front and CurrentBack/Front based on Orient changed)
			// Check for BlankLineI for CurrentBack/Front to keep backwards compat (previously CurrentBack/Front was manually changed, and Orient was automatically changed from there).
			if val.Train.CurrentBack != layout.BlankLineI && val.Train.CurrentBack != 0 {
				panic("cannot change CurrentBack using GuideTrainUpdate")
			}
			if val.Train.CurrentFront != layout.BlankLineI && val.Train.CurrentFront != 0 {
				panic("cannot change CurrentFront using GuideTrainUpdate")
			}
			if val.Train.MotorBack != 0 {
				panic("cannot change MotorBack using GuideTrainUpdate")
			}
			if val.Train.MotorFront != 0 {
				panic("cannot change MotorFront using GuideTrainUpdate")
			}
			if val.Train.State == 0 {
				val.Train.State = orig.State
			}
			if val.Train.FormI == (uuid.UUID{}) {
				val.Train.FormI = orig.FormI
			}
			if val.Train.Orient == 0 {
				if val.Train.Path != nil {
					panic("GuideTrainUpdate doesn't change Orient but Path is changed (if this is correct (i.e. Path is changed, but Orient is the same), then Path must be nil.")
				}
				val.Train.Orient = orig.Orient
			}
			if val.Train.Path == nil {
				val.Train.Path = orig.Path
			}
			if val.Train.Orient == orig.Orient {
				// same direction, so no need to recalculate Current/MotorBack/Front
			} else if val.Train.Orient == orig.Orient.Flip() {
				// opposite direction, so *need* to recalculate Current/MotorBack/Front
				val.Train.MotorBack = slices.IndexFunc(val.Train.Path.Follows, func(lp LinePort) bool { return lp.LineI == val.Train.Path.Follows[orig.MotorBack].LineI })
				val.Train.MotorFront = slices.IndexFunc(val.Train.Path.Follows, func(lp LinePort) bool { return lp.LineI == val.Train.Path.Follows[orig.MotorFront].LineI })
			}
			val.Train.Generation = orig.Generation + 1
			log.Printf("GuideTrainUpdate %#v", val.Train)
			log.Printf("GuideTrainUpdate.Path %#v", val.Train.Path)
			g.trains[val.TrainI] = val.Train
			g.updateCurrent()
			g.wakeup(val.TrainI)
		case conn.ValCurrent:
			g.handleValCurrent(diffuse, val)
		case conn.ValShortNotify:
			c := g.conf.actorsReverse[diffuse.Origin]
			li := slices.IndexFunc(g.y.Lines, func(l layout.Line) bool { return l.SwitchConn == (LineID{Conn: c, Line: val.Line}) })
			if li == -1 {
				panic(fmt.Sprintf("no line found for ValShortNotify %#v", diffuse))
			}
			ls := g.lineStates[li]
			log.Printf("lineState %#v", ls)
			if !ls.Taken {
				panic(fmt.Sprintf("ValShortNotify for non-taken line %d %#v", li, ls))
			}
			g.lineStates[li].SwitchState = ls.nextSwitchState
			g.lineStates[li].nextSwitchState = 0
			log.Printf("wakeup %d %s", ls.TakenBy, &g.trains[ls.TakenBy])
			g.wakeup(ls.TakenBy)
		}
		g.publishSnapshot()
	}
}

func reverse[S ~[]E, E any](s S) {
	for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
		s[i], s[j] = s[j], s[i]
	}
}

func (g *guide) reify(ti int, t *Train) {
	log.Printf("REIFY: %s", t)
	power := t.Power
	stop := false
	max := t.CurrentFront
	if t.State == TrainStateNextAvail {
		max += 1
	}
	for i := t.CurrentBack; i <= max; i++ {
		if g.lineStates[t.Path.Follows[i].LineI].SwitchState == SwitchStateUnsafe {
			log.Printf("=== STOP UNSAFE")
			stop = true
			power = idlePower
			break
		}
	}
	stop = stop || (t.State == TrainStateNextLocked)
	if stop {
		power = idlePower
	}
	t.noPowerSupplied = power == 0
	for i := t.CurrentBack; i <= t.CurrentFront; i++ {
		g.applySwitch(ti, t, i)
		g.apply(t, i, power)
	}
	if t.State == TrainStateNextAvail {
		g.applySwitch(ti, t, t.next())
		g.apply(t, t.next(), power)
	}
}

func (g *guide) applySwitch(ti int, t *Train, pathI int) {
	li := t.Path.Follows[pathI].LineI
	pi := t.Path.Follows[pathI].PortI
	//log.Printf("=== applySwitch path%d %s", pathI, g.y.Lines[li].Comment)
	if g.y.Lines[li].SwitchConn == (LineID{}) {
		// no switch here
		return
	}
	var targetState SwitchState
	if pi == 0 {
		// merging, so check switch is in the right direction
		var lp LinePort
		if pathI == 0 {
			lp = t.Path.Start
		} else {
			lp = t.Path.Follows[pathI-1]
		}
		p := g.y.Lines[lp.LineI].GetPort(lp.PortI)
		switch p.ConnP { // p.ConnP is what the line connecting to the merging switch connects to
		case layout.PortA:
			panic("merging from port A to port A! Cannot change direction suddenly")
		case layout.PortB:
			// The train goes from port B to A
			targetState = SwitchStateB
		case layout.PortC:
			// The train goes from port C to A
			targetState = SwitchStateC
		default:
			panic("invalid ConnP")
		}
	} else {
		if pi == 1 && g.lineStates[li].SwitchState == SwitchStateB {
			return
		} else if pi == 2 && g.lineStates[li].SwitchState == SwitchStateC {
			return
		}
		switch pi {
		case 1:
			targetState = SwitchStateB
		case 2:
			targetState = SwitchStateC
		default:
			panic(fmt.Sprintf("invalid pi %d", pi))
		}
	}
	if g.lineStates[li].SwitchState == targetState {
		return
	}
	if g.lineStates[li].SwitchState == SwitchStateUnsafe {
		// already switching
		return
	}
	g.lineStates[li].SwitchState = SwitchStateUnsafe
	g.lineStates[li].nextSwitchState = targetState

	//log.Printf("applySwitch")
	d := Diffuse1{
		Origin: g.conf.Actors[g.y.Lines[li].SwitchConn],
		Value: conn.ReqSwitch{
			Line:      g.y.Lines[li].SwitchConn.Line,
			Direction: targetState == SwitchStateB,
			// true  when targetState is B
			// false when targetState is C
			Power:    80,
			Duration: 1000,
		},
	}
	//log.Printf("diffuse %#v", d)
	g.actor.OutputCh <- d
}

func (g *guide) apply(t *Train, pathI int, power int) {
	pi := t.Path.Follows[pathI].PortI
	li := t.Path.Follows[pathI].LineI
	l := g.y.Lines[li]
	rl := conn.ReqLine{
		Line: l.PowerConn.Line,
		// NOTE: reversed for now as the layout is reversed (bodge)
		// false if port A, true if port B or C
		Power: conn.AbsClampPower(power),
	}
	g.lineStates[li].Power = rl.Power
	rl.Direction = l.GetPort(pi).Direction
	// TODO: fix direction to follow layout.Layout rules
	log.Printf("apply %s %s to %s", t, rl, g.conf.Actors[l.PowerConn])
	g.actor.OutputCh <- Diffuse1{
		Origin: g.conf.Actors[l.PowerConn],
		Value:  rl,
	}
	log.Printf("apply2 %s", rl)
}

// syncLocks verifies locking of all currents and next (if next is available) of a train.
func (g *guide) syncLocks(ti int) {
	t := g.trains[ti]
	defer func() { g.trains[ti] = t }()
	for i := t.CurrentBack; i <= t.CurrentFront; i++ {
		ok := g.lock(t.Path.Follows[i].LineI, ti)
		if !ok {
			panic(fmt.Sprintf("train %s currents %d: locking failed", &t, i))
		}
	}
	if t.CurrentFront == len(t.Path.Follows)-1 {
		// end of path
		t.State = TrainStateNextLocked
	} else {
		ok := g.lock(t.Path.Follows[t.nextUnsafe()].LineI, ti)
		if ok {
			t.State = TrainStateNextAvail
		} else {
			t.State = TrainStateNextLocked
			log.Printf("train %d: failed to lock %d", ti, t.nextUnsafe())
		}
	}
}

func (g *guide) lock(li layout.LineI, ti int) (ok bool) {
	if g.lineStates[li].Taken {
		if g.lineStates[li].TakenBy != ti {
			return false
		} else {
			return true
		}
	}
	//log.Printf("LOCK %d(%s) by %d", li, g.y.Lines[li].Comment, ti)
	g.lineStates[li].Taken = true
	g.lineStates[li].TakenBy = ti
	return true
}

func (g *guide) unlock(li layout.LineI) {
	//log.Printf("UNLOCK %d(%s) by %d", li, g.y.Lines[li].Comment, g.lineStates[li].TakenBy)
	g.lineStates[li].Taken = false
	g.lineStates[li].TakenBy = -1
	// TODO: maybe do wakeup for all trains that match (instead of the dumb for loop in guide.single())
}

type GuideTrainUpdate struct {
	TrainI int
	// Train has the updated values. Currently, only Train.Power is updated.
	// TODO: allow updating Train.Path
	Train Train
}

func (gtu GuideTrainUpdate) String() string {
	return fmt.Sprintf("GuideTrainUpdate %d %#v", gtu.TrainI, gtu.Train)
}

type GuideSnapshot struct {
	Trains     []Train
	Layout     *layout.Layout
	LineStates []LineStates
}

func (gs GuideSnapshot) String() string {
	b := new(strings.Builder)
	b.WriteString("GuideSnapshot")
	for ti, t := range gs.Trains {
		fmt.Fprintf(b, "\n%d %s", ti, &t)
	}
	return b.String()
}

func (g *guide) snapshot() GuideSnapshot {
	gs := GuideSnapshot{Trains: g.trains, Layout: g.conf.Layout, LineStates: g.lineStates}
	buf := new(bytes.Buffer)
	err := gob.NewEncoder(buf).Encode(gs)
	if err != nil {
		panic(fmt.Sprintf("snapshot: encode: %s", err))
	}
	var res GuideSnapshot
	err = gob.NewDecoder(buf).Decode(&res)
	if err != nil {
		panic(fmt.Sprintf("snapshot: decode: %s", err))
	}
	return res
}

func (g *guide) publishSnapshot() {
	g.actor.OutputCh <- Diffuse1{Value: g.snapshot()}
}

type GuideChange struct {
	TrainI   int
	Type     ChangeType
	Snapshot GuideSnapshot
}

func (gc GuideChange) String() string {
	return fmt.Sprintf("%#v", gc)
}

type ChangeType int

const (
	ChangeTypeCurrentBack ChangeType = iota + 1
	ChangeTypeCurrentFront
)

func (g *guide) publishChange(ti int, ct ChangeType) {
	//log.Printf("=== publishChange %d %#v", ti, ct)
	g.updateCurrent()
	g.actor.OutputCh <- Diffuse1{Value: GuideChange{
		TrainI:   ti,
		Type:     ct,
		Snapshot: g.snapshot(),
	}}
}
